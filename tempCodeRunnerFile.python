# Trie part 2
import random

class Node:
    def __init__(self):
        self.children = {}
        self.next_counts = {}

class NGramTrie:
    def __init__(self, names=None, order=2):
        if order < 1:
            raise ValueError("Order must be >= 1")
        self.root = Node()
        self.order = order
        self.names = set()
        self.start_counts = {}
        if names:
            self.fit(names)

    def fit(self, names):
        self.names = set(names)

        if self.names:
            max_len = max(len(n) for n in self.names)
            if self.order > max_len:
                raise ValueError(
                    f"order ({self.order}) cannot exceed the longest name length ({max_len})"
                )

        self.build_prefix_trie(self.names)
        self.build_ngram_counts(self.names)

    def successors(self, s):
        ctx = s[-(self.order - 1):] if self.order > 1 else ""
        node = self.get_node(ctx)
        return dict(node.next_counts) if node else {}
    

    def generate(self, target_len=None, max_len=20, stop_prob=0.35, rng=None, retries=500, capitalize=True):
        if target_len is not None and target_len > max_len:
            raise ValueError("target_len cannot exceed max_len")
        if rng is None:
            rng = random

        for _ in range(retries):
            candidate = self.generate_once(target_len, max_len, stop_prob, rng)
            if candidate and candidate not in self.names:
                if target_len is None or len(candidate) == target_len:
                    return candidate.capitalize() if capitalize else candidate
        return None

    def generate_once(self, target_len, max_len, stop_prob, rng):
        if self.order == 1:
            if not self.root.next_counts:
                return ""
            first = sample_weighted(self.root.next_counts, rng)
            if first is None:
                return ""
            name_chars = [first]
        else:
            if not self.start_counts:
                return ""
            start_ctx = sample_weighted(self.start_counts, rng)
            if start_ctx is None:
                return ""
            name_chars = list(start_ctx)


        while len(name_chars) < max_len:
            if target_len is not None and len(name_chars) >= target_len:
                break
            if target_len is None and rng.random() < stop_prob:
                break

            if self.order == 1:
                node = self.root
            else:
                ctx = name_chars[-(self.order - 1):]
                node = self.get_node_chars(ctx)

            if not node:
                break
            succ = node.next_counts
            if not succ:
                break
            ch = sample_weighted(succ, rng)
            if ch is None:
                break
            name_chars.append(ch)

        return "".join(name_chars)

    # ----- trie -----
    def build_prefix_trie(self, names):
        self.root = Node()
        for name in names:
            node = self.root
            for ch in name:
                if ch not in node.children:
                    node.children[ch] = Node()
                node = node.children[ch]

    def build_ngram_counts(self, names):
        self.start_counts = {}

        if self.order == 1:
            self.root.next_counts.clear()
            for name in names:
                for ch in name:
                    self.root.next_counts[ch] = self.root.next_counts.get(ch, 0) + 1
            return

        self.clear_next_counts(self.root)
        for name in names:
            if not name:
                continue
            chars = list(name)
            if len(chars) >= self.order - 1:
                start_ctx = chars[: self.order - 1]
                skey = "".join(start_ctx)
                self.start_counts[skey] = self.start_counts.get(skey, 0) + 1
            if len(chars) >= self.order:
                for i in range(len(chars) - self.order + 1):
                    ctx = chars[i: i + self.order - 1]
                    nxt = chars[i + self.order - 1]
                    ctx_node = self.ensure_path(ctx)
                    ctx_node.next_counts[nxt] = ctx_node.next_counts.get(nxt, 0) + 1

    def ensure_path(self, chars):
        node = self.root
        for ch in chars:
            if ch not in node.children:
                node.children[ch] = Node()
            node = node.children[ch]
        return node

    def get_node(self, s):
        return self.get_node_chars(list(s)) if s else self.root

    def get_node_chars(self, chars):
        node = self.root
        for ch in chars:
            node = node.children.get(ch)
            if node is None:
                return None
        return node

    def clear_next_counts(self, node):
        node.next_counts.clear()
        for child in node.children.values():
            self.clear_next_counts(child)

def sample_weighted(weights_dict, rng):
    total = sum(weights_dict.values())
    if total <= 0:
        return None
    r = rng.random() * total
    acc = 0.0
    for k, w in weights_dict.items():
        acc += w
        if r <= acc:
            return k
    for k in weights_dict:
        return k
    return None

# ---------------- Usage ----------------
if __name__ == "__main__":
    path = r"C:\Users\auror\Project\data\female.txt"
    with open(path, "r", encoding="utf-8") as f:
        names = [line.strip().lower() for line in f if line.strip()]

    print(f"Loaded {len(names)} names from female.txt")

    try:
        order = int(input("Enter desired n-gram order (e.g. 2, 3, 4): "))
    except ValueError:
        order = 3

    try:
        target_len = int(input("Enter desired name length (e.g. 6): "))
    except ValueError:
        target_len = None

    model = NGramTrie(names, order=order)

    print(f"\nGenerating names with order={order}, target_len={target_len}...")
    for _ in range(10):
        print(" ->", model.generate(target_len=target_len))
